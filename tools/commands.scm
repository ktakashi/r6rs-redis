(import (rnrs)
	(rfc http)
	(text sxml html-parser)
	(text sxml sxpath)
	(text sxml tools)
	(srfi :1)
	(srfi :13)
	(srfi :26)
	(util port)
	(sagittarius control)
	(pp))

(define server "redis.io")
(define path "/commands")

(define (main args)
  (let-values (((s h b) (http-get server path :secure? #t))
	       ((out extract) (open-string-output-port)))
    (let ((shtml (html->shtml b))
	  (path (sxpath "//li/a/span[@class = 'command']")))
      (construct-library
       (map (cut emit-definition <> out)
	    (map ->command-definition (path shtml)))
       extract))))

(define (construct-library names content-thunk)
  (print ";; -*- mode: scheme; coding: utf-8 -*-")
  (print ";; This file is automatically generated by commands.scm. DON'T EDIT!")
  (print "#!r6rs")
  (print "(library (redis commands)")
  (print "    (export " (car names))
  (for-each (lambda (name) (print "            " name)) (cdr names))
  (print "            )")
  (print "    (import (rnrs)")
  (print "            (redis api))")
  (print (content-thunk))
  (print ")"))

(define unique-name
  (let ((i 0))
    (lambda ()
      (set! i (+ i 1))
      (string-append "arg" (number->string i)))))
(define (emit-definition def out)
  (define (parse-args args)
    (define count 0)
    (define (sanitize s seen)
      (cond ((string-index s #\|) (unique-name))
	    ((member s seen)
	     (set! count (+ count 1))
	     (string-append s (number->string count)))
	    (else s)))
    (let loop ((in args) (r '()))
      (cond ((null? in) (values (reverse! r) #f))
	    ((eqv? #\[ (string-ref (car in) 0)) (values (reverse! r) in))
	    (else (loop (cdr in) (cons (sanitize (car in) r) r))))))
  (define name (string-map (lambda (c)
			     (if (char-whitespace? c)
				 #\-
				 c))
			   (string-downcase (car def))))
  (define-values (args opt?) (parse-args (cdr def)))

  (format out "~%;; ~a~%" (string-join def " "))
  (display "(define (redis-" out)
  (display name out)
  (display " redis-connection" out)
  (for-each (lambda (args) (display " " out) (display args out)) args)
  (if opt?
      (display " . opts)\n  (apply redis-send-command redis-connection " out)
      (display ")\n  (redis-send-command redis-connection " out))
  (write (car def) out)
  (for-each (lambda (args) (display " " out) (display args out)) args)
  (if opt?
      (display " opts)) " out)
      (display ")) " out))
  (newline out)
  (string-append "redis-" name))

(define (->command-definition span)
  ;; sometimes there's "s s [foo]" or so. so split...
  (define (split-if-needed line)
    (define in (open-string-input-port line))
    (define (get-token in)
      (define (read-until in pred)
	(let loop ((r '()))
	  (let ((c (get-char in)))
	    (if (pred c)
		(list->string (reverse! r))
		(loop (cons c r))))))
      (case (lookahead-char in)
	((#\[)
	 (string-append (read-until in (lambda (c) (eqv? c #\]))) "]"))
	(else =>
	 (lambda (c)
	   (if (eof-object? c)
	       c
	       (read-until in (lambda (c) (or (eof-object? c)
					      (char-whitespace? c)))))))))
    (let loop ((r '()))
      (let ((token (get-token in)))
	(if (eof-object? token)
	    (reverse! r)
	    (loop (cons token r))))))
  (define (->lines args)
    (define in (open-string-input-port args))
    (append-map split-if-needed (port->list get-line in)))
  (define (->args-list span)
    (let ((content (sxml:content span)))
      (if (null? content)
	  content
	  (let ((args (car content)))
	    (filter-map (lambda (s)
			  (let ((r (string-trim-both s)))
			    (and (not (string-null? r)) r)))
			(->lines args))))))
  (let* ((content (sxml:content span))
	 (name (car content))
	 (args (cadr content)))
    (cons (string-trim-both name)
	  (->args-list args))))
    
