(import (rnrs)
	(rfc http)
	(text json)
	(text json pointer)
	(srfi :1)
	(srfi :13)
	(srfi :26)
	(util port)
	(sagittarius control)
	(pp))

;; using commands.json from redis-doc on GitHub
;; https://raw.githubusercontent.com/antirez/redis-doc/master/commands.json

;; using /tmp for now
(define +commands-json+ "/tmp/commands.json")
(define (download-commands-definition)
  (define server "raw.githubusercontent.com")
  (define path "/antirez/redis-doc/master/commands.json")
  (unless (file-exists? +commands-json+)
    (let-values (((s h b)
		  (http-get server path
			    :receiver (http-file-receiver +commands-json+))))
      (unless (string=? s "200")
	(error 'download-commands-definition "Failed to download commands.json"
	       s)))))


(define (main args)
  (define (->name&thunk json)
    (define names
      (vector-map (lambda (e)
		    (string-append "redis-"
				   (string-map (lambda (c)
						 (if (char-whitespace? c)
						     #\-
						     c))
					       (string-downcase (car e)))))
		  json))
    (values (vector->list names) (make-content-thunk names json)))
  (download-commands-definition)
  (let-values (((names content-thunk)
		(->name&thunk
		 (call-with-input-file +commands-json+ json-read))))
    (construct-library names content-thunk)))

(define (construct-library names content-thunk)
  (print ";; -*- mode: scheme; coding: utf-8 -*-")
  (print ";; This file is automatically generated by commands.scm. DON'T EDIT!")
  (print "#!r6rs")
  (print "(library (redis commands)")
  (print "    (export " (car names))
  (for-each (lambda (name) (print "            " name)) (cdr names))
  (print "            )")
  (print "    (import (rnrs)")
  (print "            (redis api))")
  (content-thunk)
  (print)
  (print ";; internal utility")
  (print "(define (string/symbol? v) (or (string? v) (symbol? v)))")
  (print "(define (redis-value? v)")
  (print "  (or (string? v)")
  (print "      (bytevector? v)")
  (print "      (number? v)")
  (print "      (vector? v)))")
  (print "(define (convert-arguments args)")
  (print "  (define (->upper s)")
  (print "    (if (symbol? s)")
  (print "        (string-upcase (symbol->string s))")
  (print "        s))")
  (print "  (define (command c) (cons (->upper (car c)) (cdr c)))")
  (print "    (cond ((null? args) '())")
  (print "          ((pair? (car args)) (append (command (car args)) (convert-arguments (cdr args))))")
  (print "          (else (cons (->upper (car args)) (convert-arguments (cdr args))))))")
  (print "(define (%redis-send-command conn . args)")
  (print "  (apply redis-send-command conn (convert-arguments args)))")
  (print ")"))

(define (make-content-thunk names json)
  (lambda () (vector-for-each emit-definition names json)))

(define summary-pointer (json-pointer "/summary"))
(define arguments-pointer (json-pointer "/arguments"))
(define since-pointer (json-pointer "/since"))

(define optional-pointer (json-pointer "/optional"))
(define multiple-pointer (json-pointer "/multiple"))
(define argument-name-pointer (json-pointer "/name"))
(define type-pointer (json-pointer "/type"))
(define enum-pointer (json-pointer "/enum"))
(define command-pointer (json-pointer "/command"))

(define (->unique name seen)
  (if (hashtable-contains? seen name)
      (string-append
       name
       (number->string (hashtable-update! seen name (lambda (v) (+ v 1)) 0)))
      (begin
	(hashtable-set! seen name 0)
	name)))

(define (->command-signature name arguments)
  (define (emit-command-argument argument out)
    (define optional?
      (not (json-pointer-not-found? (optional-pointer argument))))
    (define multiple?
      (not (json-pointer-not-found? (multiple-pointer argument))))
    (define name (argument-name-pointer argument))
    (define enum (enum-pointer argument))
    (define command (command-pointer argument))
    (define (emit-name)
      (cond ((json-pointer-not-found? enum)
	     (if (pair? name)
		 (display (string-join name " ") out)
		 (display name out)))
	    ((pair? enum) (display (string-join enum "|") out))
	    (else (display enum out))))
    
    (display " " out)
    (when optional? (display "[" out))
    (unless (json-pointer-not-found? command)
      (display command out)
      (display " " out))
    (emit-name)
    (when multiple? (display " [" out) (emit-name) (display " ...]" out))
    (when optional? (display "]" out)))
  (let-values (((out extract) (open-string-output-port)))
    (display name out)
    (unless (json-pointer-not-found? arguments)
      (for-each (cut emit-command-argument <> out) arguments))
    (extract)))

(define (emit-definition name def)
  (define def-map (cdr def))
  (define summary (summary-pointer def-map))
  (define arguments (arguments-pointer def-map))
  (define since (since-pointer def-map))

  (define (->command-arg-name command)
    (string-append (string-downcase command) "-command"))
  (define (->arg-name argument)
    (let ((command (command-pointer argument))
	  (name (argument-name-pointer argument)))
      (if (json-pointer-not-found? command)
	  name
	  (->command-arg-name command))))
  (define scheme-arguments
    (and (not (json-pointer-not-found? arguments))
	 (do ((args arguments (cdr args))
	      (s (make-hashtable string-hash string=?))
	      (r '() (acons (car args) (->unique (->arg-name (car args)) s) r)))
	     ((or (null? args)
		  (not (json-pointer-not-found? (optional-pointer (car args))))
		  (not (json-pointer-not-found? (multiple-pointer (car args)))))
	      (if (null? args)
		  (list (reverse! r))
		  (cons (reverse! r) "opts"))))))
  
  (define (emit-scheme-impl command)
    (define (has-optional? arguments) (not (null? (cdr scheme-arguments))))
    (define (emit-arg-name argument) (display " ") (display (cdr argument)))
    (define (emit-until-optional arguments)
      (do ((args (car scheme-arguments) (cdr args)))
	  ((null? args)
	   (unless (null? (cdr scheme-arguments))
	     (display " . ")
	     (display (cdr scheme-arguments)))
	   (print ")"))
	(emit-arg-name (car args))))

    (define (emit-type-check proc-name argument)
      (define name (cdr argument))
      (define type (type-pointer (car argument)))
      (define enum (enum-pointer (car argument)))
      (define command (command-pointer (car argument)))

      (define (->scheme-predicate type)
	(cond ((string=? type "integer") 'integer?)
	      ;; enum can be string or symbol
	      ((string=? type "enum") 'string/symbol?)
	      ;; should key string?
	      ;; ((string=? type "key") 'string?)
	      ;; whatever...
	      (else 'redis-value?)))
      (define (type-check name type)
	(format #t "  (unless (~a ~a)~%" (->scheme-predicate type) name)
	(format #t "    (assertion-violation '~a \"'~a' required\" ~a))~%"
		proc-name type name))
      
      (define (command-check command name type)
	(define arg-name (->command-arg-name command))
	(define (emit-length-check len)
	  (format #t "  (unless (= (length ~a) ~a)~%" arg-name len)
	  (format #t "    (assertion-violation '~a \"Invalid '~a' command\" ~a))~%"
		proc-name command arg-name))
	(format #t "  (unless (pair? ~a)~%" arg-name)
	(format #t "    (assertion-violation '~a \"A command must be a list\" ~a))~%"
		proc-name arg-name)
	(format #t "  (unless (or (eq? '~a (car ~a)) (equal? ~s (car ~a)))~%"
		(string-downcase command) arg-name
		command arg-name)
	(format #t "    (assertion-violation '~a \"'~a' sub command required\" ~a))~%"
		proc-name command arg-name)
	(if (pair? type)
	    (emit-length-check (+ (length type) 1))
	    (emit-length-check 2))
	;; TODO command argument check
	)
	 
      (cond ((not (json-pointer-not-found? command))
	     (command-check command name type))
	    ((pair? name)
	     (for-each (lambda (name type) (type-check name type)) name type))
	    (else (type-check name type))))
    
    (format #t "(define (~a redis-connection" name)
    (if scheme-arguments
	(emit-until-optional arguments)
	(print ")"))
    (when scheme-arguments
      ;; TODO optional argument check
      (do ((args (car scheme-arguments) (cdr args)))
	  ((null? args))
	(emit-type-check name (car args))))
    (cond ((not scheme-arguments)
	   (format #t "  (%redis-send-command redis-connection ~s))~%" command))
	  ((has-optional? scheme-arguments)
	   (format #t "  (apply %redis-send-command redis-connection ~s" command)
	   (do ((args (car scheme-arguments) (cdr args)))
	       ((null? args) (print " " (cdr scheme-arguments) "))"))
	     (emit-arg-name (car args))))
	  (else
	   (format #t "  (%redis-send-command redis-connection ~s" command)
	   (for-each emit-arg-name (car scheme-arguments))
	   (print "))"))))

  (print ";; Command: " (->command-signature (car def) arguments))
  (print ";; Summary: " summary)
  (print ";; Since  : " since)
  (emit-scheme-impl (car def))
  (print)
  )
